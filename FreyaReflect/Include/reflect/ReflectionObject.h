/* File		: FreyaReflect: ReflectionObject.h
 * Author	: Dmitry Vedenko
 * E-Mail	: dmitry.vedenko@freya3d.org
 *
 * This file is a part of Freya3D Engine.
 */

#ifndef Reflect_ReflectionObject_h__
#define Reflect_ReflectionObject_h__

#include "FreyaReflectInternal.h"
#include "reflect/reflect_cast.h"
#include "containers/type_utils.h"

namespace reflect
{

#define REFLECTION_OBJECT() \
	static  reflect::Class* GetClass(); \
	virtual reflect::Class* getClass() const { return GetClass(); }

	class Class;

	//! Base class for all objects, reflected to the reflection database
	/*!
	 * The class provides two methods, used to identify the concrete objects:
	 * - static  reflect::Class* GetClass();
	 * - virtual reflect::Class* getClass() const;
	 *
	 * Any object, which wants to provide access to its reflection data. Thought,
	 * just to use reflect::reflect_cast or provide the access to metaclass one 
	 * could only insert a REFLECTION_OBJECT(); string into the public section and
	 * implement reflect::Class* GetClass() to return the correct metaclass (this method
	 * is generated by reflection generator). Still, if a class wants to be created by
	 * the meta class it should be also inherited from the ReflectionObject
	 * \ingroup grpFreyaReflect
	 */
	class FREYA_REFLECT_EXPORT ReflectionObject
	{
	public:
		//! This macro should in the public section of every class wanting to provide the reflection information
		REFLECTION_OBJECT();

		//! Try to cast an object to the type T* using reflect::reflect_cast
		template<typename T>
		T*     castTo() { return reflect_cast<T>(this); }

		//! Try to cast an object to the type T* using reflect::reflect_cast (constant version)
		template<typename T>
		typename containers::const_pointer<T>::type
			castTo() const { return reflect_cast<T>(this); }
	};
} // namespace reflect

#endif // Reflect_Class_h__