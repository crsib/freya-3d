// forbid.gr.gen.cc
// *** DO NOT EDIT BY HAND ***
// automatically generated by gramanl, from forbid.gr

// GLR source location information is enabled

#include "forbid.gr.gen.h"     // Forbid
#include "parsetables.h" // ParseTables
#include "srcloc.h"      // SourceLoc

#include <assert.h>      // assert
#include <iostream>      // cout
#include <stdlib.h>      // abort

static char const *termNames[] = {
  "CHAR_EOF",  // 0
  "__dummy_filler_token1",  // 1
  "__dummy_filler_token2",  // 2
  "__dummy_filler_token3",  // 3
  "__dummy_filler_token4",  // 4
  "__dummy_filler_token5",  // 5
  "__dummy_filler_token6",  // 6
  "__dummy_filler_token7",  // 7
  "__dummy_filler_token8",  // 8
  "__dummy_filler_token9",  // 9
  "__dummy_filler_token10",  // 10
  "__dummy_filler_token11",  // 11
  "__dummy_filler_token12",  // 12
  "__dummy_filler_token13",  // 13
  "__dummy_filler_token14",  // 14
  "__dummy_filler_token15",  // 15
  "__dummy_filler_token16",  // 16
  "__dummy_filler_token17",  // 17
  "__dummy_filler_token18",  // 18
  "__dummy_filler_token19",  // 19
  "__dummy_filler_token20",  // 20
  "__dummy_filler_token21",  // 21
  "__dummy_filler_token22",  // 22
  "__dummy_filler_token23",  // 23
  "__dummy_filler_token24",  // 24
  "__dummy_filler_token25",  // 25
  "__dummy_filler_token26",  // 26
  "__dummy_filler_token27",  // 27
  "__dummy_filler_token28",  // 28
  "__dummy_filler_token29",  // 29
  "__dummy_filler_token30",  // 30
  "__dummy_filler_token31",  // 31
  "__dummy_filler_token32",  // 32
  "__dummy_filler_token33",  // 33
  "__dummy_filler_token34",  // 34
  "__dummy_filler_token35",  // 35
  "__dummy_filler_token36",  // 36
  "__dummy_filler_token37",  // 37
  "__dummy_filler_token38",  // 38
  "__dummy_filler_token39",  // 39
  "__dummy_filler_token40",  // 40
  "__dummy_filler_token41",  // 41
  "__dummy_filler_token42",  // 42
  "__dummy_filler_token43",  // 43
  "__dummy_filler_token44",  // 44
  "__dummy_filler_token45",  // 45
  "__dummy_filler_token46",  // 46
  "__dummy_filler_token47",  // 47
  "__dummy_filler_token48",  // 48
  "__dummy_filler_token49",  // 49
  "__dummy_filler_token50",  // 50
  "__dummy_filler_token51",  // 51
  "__dummy_filler_token52",  // 52
  "__dummy_filler_token53",  // 53
  "__dummy_filler_token54",  // 54
  "__dummy_filler_token55",  // 55
  "__dummy_filler_token56",  // 56
  "__dummy_filler_token57",  // 57
  "__dummy_filler_token58",  // 58
  "__dummy_filler_token59",  // 59
  "__dummy_filler_token60",  // 60
  "__dummy_filler_token61",  // 61
  "__dummy_filler_token62",  // 62
  "__dummy_filler_token63",  // 63
  "__dummy_filler_token64",  // 64
  "__dummy_filler_token65",  // 65
  "__dummy_filler_token66",  // 66
  "__dummy_filler_token67",  // 67
  "__dummy_filler_token68",  // 68
  "__dummy_filler_token69",  // 69
  "__dummy_filler_token70",  // 70
  "__dummy_filler_token71",  // 71
  "__dummy_filler_token72",  // 72
  "__dummy_filler_token73",  // 73
  "__dummy_filler_token74",  // 74
  "__dummy_filler_token75",  // 75
  "__dummy_filler_token76",  // 76
  "__dummy_filler_token77",  // 77
  "__dummy_filler_token78",  // 78
  "__dummy_filler_token79",  // 79
  "__dummy_filler_token80",  // 80
  "__dummy_filler_token81",  // 81
  "__dummy_filler_token82",  // 82
  "__dummy_filler_token83",  // 83
  "__dummy_filler_token84",  // 84
  "__dummy_filler_token85",  // 85
  "__dummy_filler_token86",  // 86
  "__dummy_filler_token87",  // 87
  "__dummy_filler_token88",  // 88
  "__dummy_filler_token89",  // 89
  "__dummy_filler_token90",  // 90
  "__dummy_filler_token91",  // 91
  "__dummy_filler_token92",  // 92
  "__dummy_filler_token93",  // 93
  "__dummy_filler_token94",  // 94
  "__dummy_filler_token95",  // 95
  "__dummy_filler_token96",  // 96
  "CHAR_A",  // 97
  "CHAR_B",  // 98
};

sm::string Forbid::terminalDescription(int termId, SemanticValue sval)
{
  return stringc << termNames[termId]
                 << "(" << (sval % 100000) << ")";
}


static char const *nontermNames[] = {
  "empty",  // 0
  "__EarlyStartSymbol",  // 1
  "Start",  // 2
  "TopA",  // 3
  "A",  // 4
};

sm::string Forbid::nonterminalDescription(int nontermId, SemanticValue sval)
{
  return stringc << nontermNames[nontermId]
                 << "(" << (sval % 100000) << ")";
}


char const *Forbid::terminalName(int termId)
{
  return termNames[termId];
}

char const *Forbid::nonterminalName(int nontermId)
{
  return nontermNames[nontermId];
}

// ------------------- actions ------------------
// [0] __EarlyStartSymbol[void] -> top:Start CHAR_EOF
inline void Forbid::action0___EarlyStartSymbol(SourceLoc loc, SourceLoc endloc, SemanticValue top)
#line 1 "<init>"
{ return;  }
#line 155 "forbid.gr.gen.cc"

// [1] Start[void] -> TopA TopA
inline void Forbid::action1_Start(SourceLoc loc, SourceLoc endloc)
{return; }
// [2] TopA[void] -> b A
inline void Forbid::action2_TopA(SourceLoc loc, SourceLoc endloc)
{return; }
// [3] TopA[void] -> A
inline void Forbid::action3_TopA(SourceLoc loc, SourceLoc endloc)
{return; }
// [4] A[void] -> a
inline void Forbid::action4_A(SourceLoc loc, SourceLoc endloc)
{return; }
// [5] A[void] -> a b A
inline void Forbid::action5_A(SourceLoc loc, SourceLoc endloc)
{return; }

/*static*/ SemanticValue Forbid::doReductionAction(
  Forbid *ths,
  int productionId, SemanticValue const *semanticValues,
  SourceLoc loc,
  SourceLoc endloc)
{
  switch (productionId) {
    case 0:
      return (SemanticValue)(ths->action0___EarlyStartSymbol(loc, endloc, (SemanticValue)(semanticValues[0])), 0);
    case 1:
      return (SemanticValue)(ths->action1_Start(loc, endloc), 0);
    case 2:
      return (SemanticValue)(ths->action2_TopA(loc, endloc), 0);
    case 3:
      return (SemanticValue)(ths->action3_TopA(loc, endloc), 0);
    case 4:
      return (SemanticValue)(ths->action4_A(loc, endloc), 0);
    case 5:
      return (SemanticValue)(ths->action5_A(loc, endloc), 0);
    default:
      assert(!"invalid production code");
      return (SemanticValue)0;   // silence warning
  }
}

UserActions::ReductionActionFunc Forbid::getReductionAction()
{
  return (ReductionActionFunc)&Forbid::doReductionAction;
}


// ---------------- dup/del/merge/keep nonterminals ---------------

SemanticValue Forbid::duplicateNontermValue(int nontermId, SemanticValue sval)
{
  switch (nontermId) {
    case 1:
      return sval;
    case 2:
      return sval;
    case 3:
      return sval;
    case 4:
      return sval;
    default:
      return (SemanticValue)0;
  }
}

void Forbid::deallocateNontermValue(int nontermId, SemanticValue sval)
{
  switch (nontermId) {
    case 1:
      break;
    case 2:
      break;
    case 3:
      break;
    case 4:
      break;
    default:
      std::cout << "WARNING: there is no action to deallocate nonterm "
           << nontermNames[nontermId] << std::endl;
  }
}

SemanticValue Forbid::mergeAlternativeParses(int nontermId, SemanticValue left,
                                           SemanticValue right,  SourceLoc loc)
{
  switch (nontermId) {
    default:
      std::cout << toString(loc) 
           << ": WARNING: there is no action to merge nonterm "
           << nontermNames[nontermId] << std::endl;
      return left;
  }
}

bool Forbid::keepNontermValue(int nontermId, SemanticValue sval)
{
  switch (nontermId) {
    default:
      return true;
  }
}


// ---------------- dup/del/classify terminals ---------------
SemanticValue Forbid::duplicateTerminalValue(int termId, SemanticValue sval)
{
  switch (termId) {
    case 0:
      return sval;
    case 97:
      return sval;
    case 98:
      return sval;
    case 1:
      return sval;
    case 2:
      return sval;
    case 3:
      return sval;
    case 4:
      return sval;
    case 5:
      return sval;
    case 6:
      return sval;
    case 7:
      return sval;
    case 8:
      return sval;
    case 9:
      return sval;
    case 10:
      return sval;
    case 11:
      return sval;
    case 12:
      return sval;
    case 13:
      return sval;
    case 14:
      return sval;
    case 15:
      return sval;
    case 16:
      return sval;
    case 17:
      return sval;
    case 18:
      return sval;
    case 19:
      return sval;
    case 20:
      return sval;
    case 21:
      return sval;
    case 22:
      return sval;
    case 23:
      return sval;
    case 24:
      return sval;
    case 25:
      return sval;
    case 26:
      return sval;
    case 27:
      return sval;
    case 28:
      return sval;
    case 29:
      return sval;
    case 30:
      return sval;
    case 31:
      return sval;
    case 32:
      return sval;
    case 33:
      return sval;
    case 34:
      return sval;
    case 35:
      return sval;
    case 36:
      return sval;
    case 37:
      return sval;
    case 38:
      return sval;
    case 39:
      return sval;
    case 40:
      return sval;
    case 41:
      return sval;
    case 42:
      return sval;
    case 43:
      return sval;
    case 44:
      return sval;
    case 45:
      return sval;
    case 46:
      return sval;
    case 47:
      return sval;
    case 48:
      return sval;
    case 49:
      return sval;
    case 50:
      return sval;
    case 51:
      return sval;
    case 52:
      return sval;
    case 53:
      return sval;
    case 54:
      return sval;
    case 55:
      return sval;
    case 56:
      return sval;
    case 57:
      return sval;
    case 58:
      return sval;
    case 59:
      return sval;
    case 60:
      return sval;
    case 61:
      return sval;
    case 62:
      return sval;
    case 63:
      return sval;
    case 64:
      return sval;
    case 65:
      return sval;
    case 66:
      return sval;
    case 67:
      return sval;
    case 68:
      return sval;
    case 69:
      return sval;
    case 70:
      return sval;
    case 71:
      return sval;
    case 72:
      return sval;
    case 73:
      return sval;
    case 74:
      return sval;
    case 75:
      return sval;
    case 76:
      return sval;
    case 77:
      return sval;
    case 78:
      return sval;
    case 79:
      return sval;
    case 80:
      return sval;
    case 81:
      return sval;
    case 82:
      return sval;
    case 83:
      return sval;
    case 84:
      return sval;
    case 85:
      return sval;
    case 86:
      return sval;
    case 87:
      return sval;
    case 88:
      return sval;
    case 89:
      return sval;
    case 90:
      return sval;
    case 91:
      return sval;
    case 92:
      return sval;
    case 93:
      return sval;
    case 94:
      return sval;
    case 95:
      return sval;
    case 96:
      return sval;
    default:
      return (SemanticValue)0;
  }
}

void Forbid::deallocateTerminalValue(int termId, SemanticValue sval)
{
  switch (termId) {
    case 0:
      break;
    case 97:
      break;
    case 98:
      break;
    case 1:
      break;
    case 2:
      break;
    case 3:
      break;
    case 4:
      break;
    case 5:
      break;
    case 6:
      break;
    case 7:
      break;
    case 8:
      break;
    case 9:
      break;
    case 10:
      break;
    case 11:
      break;
    case 12:
      break;
    case 13:
      break;
    case 14:
      break;
    case 15:
      break;
    case 16:
      break;
    case 17:
      break;
    case 18:
      break;
    case 19:
      break;
    case 20:
      break;
    case 21:
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 27:
      break;
    case 28:
      break;
    case 29:
      break;
    case 30:
      break;
    case 31:
      break;
    case 32:
      break;
    case 33:
      break;
    case 34:
      break;
    case 35:
      break;
    case 36:
      break;
    case 37:
      break;
    case 38:
      break;
    case 39:
      break;
    case 40:
      break;
    case 41:
      break;
    case 42:
      break;
    case 43:
      break;
    case 44:
      break;
    case 45:
      break;
    case 46:
      break;
    case 47:
      break;
    case 48:
      break;
    case 49:
      break;
    case 50:
      break;
    case 51:
      break;
    case 52:
      break;
    case 53:
      break;
    case 54:
      break;
    case 55:
      break;
    case 56:
      break;
    case 57:
      break;
    case 58:
      break;
    case 59:
      break;
    case 60:
      break;
    case 61:
      break;
    case 62:
      break;
    case 63:
      break;
    case 64:
      break;
    case 65:
      break;
    case 66:
      break;
    case 67:
      break;
    case 68:
      break;
    case 69:
      break;
    case 70:
      break;
    case 71:
      break;
    case 72:
      break;
    case 73:
      break;
    case 74:
      break;
    case 75:
      break;
    case 76:
      break;
    case 77:
      break;
    case 78:
      break;
    case 79:
      break;
    case 80:
      break;
    case 81:
      break;
    case 82:
      break;
    case 83:
      break;
    case 84:
      break;
    case 85:
      break;
    case 86:
      break;
    case 87:
      break;
    case 88:
      break;
    case 89:
      break;
    case 90:
      break;
    case 91:
      break;
    case 92:
      break;
    case 93:
      break;
    case 94:
      break;
    case 95:
      break;
    case 96:
      break;
    default:
      std::cout << "WARNING: there is no action to deallocate terminal "
           << termNames[termId] << std::endl;
  }
}

/*static*/ int Forbid::reclassifyToken(Forbid *ths, int oldTokenType, SemanticValue sval)
{
  switch (oldTokenType) {
    default:
      return oldTokenType;
  }
}

UserActions::ReclassifyFunc Forbid::getReclassifier()
{
  return (ReclassifyFunc)&Forbid::reclassifyToken;
}


// this makes a ParseTables from some literal data;
// the code is written by ParseTables::emitConstructionCode()
// in parsetables.cc
class Forbid_ParseTables : public ParseTables {
public:
  Forbid_ParseTables();
};

Forbid_ParseTables::Forbid_ParseTables()
  : ParseTables(false /*owning*/)
{
  numTerms = 99;
  numNonterms = 5;
  numStates = 11;
  numProds = 6;
  actionCols = 99;
  actionRows = 11;
  gotoCols = 5;
  gotoRows = 11;
  ambigTableSize = 0;
  startState = (StateId)0;
  finalProductionIndex = 0;
  bigProductionListSize = 0;
  errorBitsRowSize = 16;
  uniqueErrorRows = 0;

  // storage size: 2178 bytes
  // rows: 11  cols: 99
  static ActionEntry const actionTable_static[1089] = {
    /* 0*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 
    /* 1*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    /* 2*/ -5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -5, 5, 
    /* 3*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 
    /* 4*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 
    /* 5*/ 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    /* 6*/ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 
    /* 7*/ -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    /* 8*/ -4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -4, -4, 
    /* 9*/ -3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, -3, 
    /*10*/ -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, -6, 
  };
  actionTable = const_cast<ActionEntry*>(actionTable_static);

  // storage size: 110 bytes
  // rows: 11  cols: 5
  static GotoEntry const gotoTable_static[55] = {
    /* 0*/ 65535, 65535, 5, 6, 8, 
    /* 1*/ 65535, 65535, 65535, 65535, 65535, 
    /* 2*/ 65535, 65535, 65535, 65535, 65535, 
    /* 3*/ 65535, 65535, 65535, 65535, 9, 
    /* 4*/ 65535, 65535, 65535, 65535, 10, 
    /* 5*/ 65535, 65535, 65535, 65535, 65535, 
    /* 6*/ 65535, 65535, 65535, 7, 8, 
    /* 7*/ 65535, 65535, 65535, 65535, 65535, 
    /* 8*/ 65535, 65535, 65535, 65535, 65535, 
    /* 9*/ 65535, 65535, 65535, 65535, 65535, 
    /*10*/ 65535, 65535, 65535, 65535, 65535, 
  };
  gotoTable = const_cast<GotoEntry*>(gotoTable_static);

  static ParseTables::ProdInfo const prodInfo_static[6] = {
    /*0*/ {2,1}, {2,2}, {2,3}, {1,3}, {1,4}, {3,4}, 
  };
  prodInfo = const_cast<ParseTables::ProdInfo*>(prodInfo_static);

  static SymbolId const stateSymbol_static[11] = {
    /*0*/ 0, 1, 98, 99, 99, -3, -4, -4, -5, -5, -5, 
  };
  stateSymbol = const_cast<SymbolId*>(stateSymbol_static);

  ActionEntry *ambigTable_static = NULL;
  ambigTable = const_cast<ActionEntry*>(ambigTable_static);

  static NtIndex const nontermOrder_static[5] = {
    /*0*/ 4, 3, 2, 1, 0, 
  };
  nontermOrder = const_cast<NtIndex*>(nontermOrder_static);

  ErrorBitsEntry *errorBits_static = NULL;
  errorBits = const_cast<ErrorBitsEntry*>(errorBits_static);

  errorBitsPointers = NULL;

  TermIndex *actionIndexMap_static = NULL;
  actionIndexMap = const_cast<TermIndex*>(actionIndexMap_static);

  actionRowPointers = NULL;

  NtIndex *gotoIndexMap_static = NULL;
  gotoIndexMap = const_cast<NtIndex*>(gotoIndexMap_static);

  gotoRowPointers = NULL;

  firstWithTerminal = NULL;
  firstWithNonterminal = NULL;
  bigProductionList = NULL;
  productionsForState = NULL;
  ambigStateTable = NULL;
}


ParseTables *Forbid::makeTables()
{
  return new Forbid_ParseTables;
}

